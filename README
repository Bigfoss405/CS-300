1. What was the problem you were solving in the projects for this course?
In this course, I worked on projects to develop software for ABC University.
In Project One, I created pseudocode to design a program, focusing on how to solve problems using algorithms and data structures.
In Project Two, I turned that pseudocode into working code, solving basic programming problems and making sure the program ran efficiently​.

2. How did you approach the problem? Consider why data structures are important to understand.
I started by breaking the problem into smaller parts to figure out what the program needed to do. I then:
Wrote pseudocode to outline the steps.
Chose the right data structures based on the operations needed.
Data structures are important because they make it easier and faster to organize and process data. For example, I used arrays for storing lists of items and hash maps for quick searches.

3. How did you overcome any roadblocks you encountered while going through the activities or project?
When I ran into problems, like errors in my code or slow performance:
I tested small parts of the program step by step to find where things went wrong.
I used tools like print statements to check my results.
If one data structure didn’t work well, I tried another one. For example, I switched from arrays to hash maps to improve speed.
I also reviewed examples from the course and asked for help when needed.

4. How has your work on this project expanded your approach to designing software and developing programs?
These projects taught me to:
-Start with a plan (pseudocode) before writing code.
-Think about how the program will handle larger amounts of data.
-Write code in smaller, manageable parts so it’s easier to test and fix.

5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I now focus on:
-Readability: Using clear variable names and adding comments so others can understand my code.
-Maintainability: Breaking my program into smaller functions, making it easier to update or fix.
-Adaptability: Writing code that can handle changes in the future without needing a full rewrite.
-By practicing these steps, I’ve learned how to write cleaner, more organized code that’s easier to work with.
